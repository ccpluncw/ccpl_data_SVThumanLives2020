require(dplyr)#
library(minpack.lm)#
#
minN <- 20#
#
analysisReadyData<-read.table("analysisReadyData.sn.txt", header=T, sep="\t")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = gray(col.g[i]),...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == conds[i], ], points(x,y, pch = 16, col=gray(col.g[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(conds)) {#
        with(df.tmp[df.tmp$cond == conds[i], ], lines(x,fit, col=gray(col.g[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
df.rwPhit<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, direct.xVy) %>% summarise(rt = mean(res.RT)+1, pHit = mean(correct01)))#
filename <- "tmpPhit.pdf"#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
analysisReadyData.sn<-read.table("analysisReadyData.sn.txt", header=T, sep="\t")#
#
### direct.xvy = -1 means the lower valued object will be killed by default: do nothing#
### direct.xvy = 1 means the higher valued object will be killed by default: act#
df.rwPhit<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, direct.xVy) %>% summarise(rt = mean(res.RT)+1, pHit = mean(correct01)))#
filename <- "tmpPhit.pdf"
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == conds[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(conds)) {#
        with(df.tmp[df.tmp$cond == conds[i], ], lines(x,fit, col=gray(col.g[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(conds)) {#
        with(df.tmp[df.tmp$cond == conds[i], ], lines(x,fit, col=gray(col.g[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(conds)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond")#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond")#
print(df.legendVals)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", placement = "center")#
print(df.legendVals)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=8, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,7), las=1, cex=2)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,7), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")
ch.updateRpackage (packageName = "chutils")
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,7), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)", inset = c(-2,0))
warnings()
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
#    conds <- unique(df.tmp$cond)#
#    col.g <- seq(0, .75, .75/(length(conds)-1) )#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,7), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
?par
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,9), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.legendVals$h[i],df.legendVals$s[i],df.legendVals$v[i]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.legendVals$h[i],df.legendVals$s[i],df.legendVals$v[i]), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.legendVals$h[i],df.legendVals$s[i],df.legendVals$v[i]), lty=df.legendVals$lty[i]))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          col.rgb[1] <- .9#
          col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          if (i != thresholdCondVal[1]){#
            col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
            col.rgb[3] <- .9#
          }#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=rgb(col.rgb[1],col.rgb[2],col.rgb[3])))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
f.rwRT<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, correct01, direct.xVy) %>% summarise(rt = mean(res.RT)+1, n = length(correct01)))#
#
df.rwRT$thresh <- 10#
df.rwRT <- df.rwRT[df.rwRT$n > minN, ]
df.rwRT<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, correct01, direct.xVy) %>% summarise(rt = mean(res.RT)+1, n = length(correct01)))#
#
df.rwRT$thresh <- 10#
df.rwRT <- df.rwRT[df.rwRT$n > minN, ]#
#
filename <- "tmpRB.pdf"#
n
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
xx
df.rwRT
grps <- c("correct01", "direct.xVy")
df.grpIndex <- ch.getGrpIndex (df.rwRT, grps)
df.grpIndex
df.legendVals <- ch.getPlotLegendVals(df.grpIndex)
df.legendVals
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty)))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
df.rwRT<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, correct01, direct.xVy) %>% summarise(rt = mean(res.RT)+1, n = length(correct01)))#
#
df.rwRT$thresh <- 10#
df.rwRT <- df.rwRT[df.rwRT$n > minN, ]#
#
filename <- "tmpRB.pdf"
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
print(df.lgnd)#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
?lty
?lines
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")
ch.updateRpackage (packageName = "chutils")
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
plot(c(1,2,3), c(1,2,3), type="l", lty=1)
plot(c(1,2,3), c(1,2,3), type="l", lty=1)
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
print(df.lgnd)#
print(typeof(df.lgnd$lty))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
print(df.lgnd)#
print(typeof(df.lgnd$lty))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=33))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[j],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
dev.off()
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print(typeof(df.lgnd$lty))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
dev.off()
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
dev.off()
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
dev.off()
dev.off()
dev.off()
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
plot(c(1,2,3), c(1,2,3), type="l", lty=33)
lines(c(3,2,1), c(1,2,3), lty=33)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print(typeof(df.lgnd$lty))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print(typeof(df.lgnd$lty))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
library(chutils)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print(typeof(df.lgnd$lty))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print((df.legendVals))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")#
ch.updateRpackage (packageName = "chutils")
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print((df.legendVals))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")#
ch.updateRpackage (packageName = "chutils")
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print((df.legendVals))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")#
ch.updateRpackage (packageName = "chutils")
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")#
ch.updateRpackage (packageName = "chutils")
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(respBiasConds)-1))#
#
#    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
print(df.lgnd)#
print((df.legendVals))#
          if (newPlot) {#
#            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=rgb(col.rgb[1],col.rgb[2],col.rgb[3]), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=as.character(df.lgnd$lty)))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
library(chutils)#
unloadNamespace("chMorals")#
unloadNamespace("chValues")#
ch.updateRpackage (packageName = "chutils")
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            print(df.lgnd$lty)#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    ch.addLegend(df.legendVals, grps, ...)#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    ch.addLegend(df.legendVals, grps, ...)#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
#
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
#
    ch.addLegend(df.legendVals, grps, ...)#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
#
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=16))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
?sin
pi
sin(180 * (pi/180))
sin(180 * (pi/180))+1
sin(180 * (pi/180))+.01
sin(185 * (pi/180))+.01
require(dplyr)#
library(minpack.lm)#
#
minN <- 20#
#
analysisReadyData.sn<-read.table("analysisReadyData.sn.txt", header=T, sep="\t")#
#
### direct.xvy = -1 means the lower valued object will be killed by default: do nothing#
### direct.xvy = 1 means the higher valued object will be killed by default: act#
df.rwPhit<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, direct.xVy) %>% summarise(rt = mean(res.RT)+1, pHit = mean(correct01)))#
filename <- "tmpPhit.pdf"#
#
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$direct.xVy, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")#
#
df.rwRT<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, correct01, direct.xVy) %>% summarise(rt = mean(res.RT)+1, n = length(correct01)))#
#
df.rwRT$thresh <- 10#
df.rwRT <- df.rwRT[df.rwRT$n > minN, ]
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotOverlapDependentRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotOverlapDependentRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= -1, r1=4), filename=filename)
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotOverlapDependentRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "direct.xVy", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= 1, r1=4), filename=filename)
require(dplyr)#
library(minpack.lm)#
#
minN <- 20#
#
analysisReadyData.sn<-read.table("analysisReadyData.sn.txt", header=T, sep="\t")#
#
### direct.xvy = -1 means the lower valued object will be killed by default: do nothing#
### direct.xvy = 1 means the higher valued object will be killed by default: act#
df.rwPhit<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, direct.xVy) %>% summarise(rt = mean(res.RT)+1, pHit = mean(correct01)))#
filename <- "tmpPhit.pdf"#
#
df.rwPhit$act <- ifelse(df.rwPhit$direct.xvy == -1, 1, -1)#
#
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$act, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")#
#
df.rwRT<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, correct01, direct.xVy) %>% summarise(rt = mean(res.RT)+1, n = length(correct01)))#
#
df.rwRT$act <- ifelse(df.rwRT$direct.xvy == -1, 1, -1)#
#
df.rwRT$thresh <- 10#
df.rwRT <- df.rwRT[df.rwRT$n > minN, ]
df.rwPhit$direct.xvy
df.rwPhit<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, direct.xVy) %>% summarise(rt = mean(res.RT)+1, pHit = mean(correct01)))
df.rwPhit
ifelse(df.rwPhit$direct.xvy == -1, 1, -1)
require(dplyr)#
library(minpack.lm)#
#
minN <- 20#
#
analysisReadyData.sn<-read.table("analysisReadyData.sn.txt", header=T, sep="\t")#
#
### direct.xVy = -1 means the lower valued object will be killed by default: do nothing#
### direct.xVy = 1 means the higher valued object will be killed by default: act#
df.rwPhit<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, direct.xVy) %>% summarise(rt = mean(res.RT)+1, pHit = mean(correct01)))#
filename <- "tmpPhit.pdf"#
#
df.rwPhit$act <- ifelse(df.rwPhit$direct.xVy == -1, 1, -1)#
#
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$act, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")#
#
df.rwRT<-data.frame(analysisReadyData.sn %>% group_by(overlapRound, correct01, direct.xVy) %>% summarise(rt = mean(res.RT)+1, n = length(correct01)))#
#
df.rwRT$act <- ifelse(df.rwRT$direct.xVy == -1, 1, -1)#
#
df.rwRT$thresh <- 10#
df.rwRT <- df.rwRT[df.rwRT$n > minN, ]
filename <- "tmpRB.pdf"#
nls.out.rt.rb <- ch.fitAndPlotOverlapDependentRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "act", "correct01", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=1, k=2, r=1, a1 = -1, k1= 1, r1=4), filename=filename)
nls.out.rt.rb
source("moralsRespBias.r")
source("moralsRespBias.r")
head(analysisReadyData)
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
nls.out.rt
analysisReadyData<-read.table("moralsGrpDataRTresid.txt", header=T, sep="\t")
head(analysisReadyData)
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
nls.out.rt
source("moralsRespBias.r")
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=-Inf,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
source("moralsRespBias.r")
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=-Inf,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
source("moralsRespBias.r")
nls.out.rt
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
source("moralsRespBias.r")
source("moralsRespBias.r")
nls.out.rt.2
nls.out.rt
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r", echo=T)
df.rwRT
nls.out.rt <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "act", "correct1", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=.5, k=2, r=1, a1 = -.1, k1= .1, r1=4), filename=filename)
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}
nls.out.rt <- ch.fitAndPlotRespBiasEffect.rt(df.rwRT, "overlapRound", "rt", "act", "correct1", correctVals = c(1,0), "thresh", thresholdCondVal = c(10), startVals = c(a=.5, k=2, r=1, a1 = -.1, k1= .1, r1=4), filename=filename)
source("moralsRespBias.r", echo=T)
source("moralsRespBias.r", echo=T)
source("moralsRespBias.r", echo=T)
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
head(analysisReadyData.sn)
source("moralsRespBias.r")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.grpIndex$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.grpIndex$cond)) {#
        with(df.tmp[df.tmp$cond == df.grpIndex$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
print(df.legendVals)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
source("moralsRespBias.r")
x <- df.rwPhit$overlapRound
y <- df.rwPhit$pHit
cond <- df.rwPhit$act
df.rwPhit
df.tmp <- data.frame(x = x, y = y, cond = cond)
df.tmp
df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)
df.grpIndex
df.legendVals
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
print(df.legendVals)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
print(df.legendVals)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}#
ch.fitAndPlotValueChangeEffect.rt <- function (data, overlapRoundCol,rtCol, valueCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 10, r1=.5, t1=1, t2 = 1, r2=0), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    library(minpack.lm)#
    library(chutils)#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$vChange <- data[[valueCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(valueCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a+thresh*t1)) * (k+thresh*t2) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k+thresh*t2) + (vChange*a1+a+thresh*t1)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf, t1=Inf, t2=Inf, r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, t1=0,t2=0, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a)) * (k) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k) + (vChange*a1+a)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf,r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    valConds <- unique (data[[valueCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(valConds)-1))#
#
    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Value Change Model Fit: all thresholds::Values::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Value Change Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          # col.rgb[1] <- .9#
          # col.rgb[2] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # col.rgb[3] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          # if (i != thresholdCondVal[1]){#
          #   col.rgb[1] <- ifelse(j == correctVals[1], colSeq[k], .5+colSeq[k])#
          #   col.rgb[3] <- .9#
          # }#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty)))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}#
#
summarizeBootOutputCV2 <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  rw.df$correct01 <- ifelse(rw.df$correct == TRUE, 1, 0)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
source("moralsRespBias.r")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
source("moralsRespBias.r")
ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$act, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpPhit.pdf"#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$act, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
filename <- "tmpPhit.pdf"#
nls.out.phit <- ch.fitAndPlotCondition.pHit(df.rwPhit$overlapRound,df.rwPhit$pHit, df.rwPhit$act, filename=filename, cex1 = 1, printR2 = T,yLabel="p(hit)")
source("moralsRespBias.r")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}#
ch.fitAndPlotValueChangeEffect.rt <- function (data, overlapRoundCol,rtCol, valueCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 10, r1=.5, t1=1, t2 = 1, r2=0), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    library(minpack.lm)#
    library(chutils)#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$vChange <- data[[valueCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(valueCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a+thresh*t1)) * (k+thresh*t2) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k+thresh*t2) + (vChange*a1+a+thresh*t1)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf, t1=Inf, t2=Inf, r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, t1=0,t2=0, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a)) * (k) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k) + (vChange*a1+a)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf,r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    valConds <- unique (data[[valueCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(valConds)-1))#
#
    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Value Change Model Fit: all thresholds::Values::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Value Change Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty)))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Overlap Dependent Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Overlap Dependent Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}#
#
summarizeBootOutputCV2 <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  rw.df$correct01 <- ifelse(rw.df$correct == TRUE, 1, 0)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}#
ch.fitAndPlotValueChangeEffect.rt <- function (data, overlapRoundCol,rtCol, valueCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 10, r1=.5, t1=1, t2 = 1, r2=0), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    library(minpack.lm)#
    library(chutils)#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$vChange <- data[[valueCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(valueCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a+thresh*t1)) * (k+thresh*t2) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k+thresh*t2) + (vChange*a1+a+thresh*t1)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf, t1=Inf, t2=Inf, r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, t1=0,t2=0, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a)) * (k) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k) + (vChange*a1+a)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf,r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    valConds <- unique (data[[valueCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(valConds)-1))#
#
    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Value Change Model Fit: all thresholds::Values::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Value Change Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty)))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Overlap Dependent Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Overlap Dependent Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}#
#
summarizeBootOutputCV2 <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  rw.df$correct01 <- ifelse(rw.df$correct == TRUE, 1, 0)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}#
ch.fitAndPlotValueChangeEffect.rt <- function (data, overlapRoundCol,rtCol, valueCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 10, r1=.5, t1=1, t2 = 1, r2=0), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    library(minpack.lm)#
    library(chutils)#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$vChange <- data[[valueCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(valueCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a+thresh*t1)) * (k+thresh*t2) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k+thresh*t2) + (vChange*a1+a+thresh*t1)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf, t1=Inf, t2=Inf, r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, t1=0,t2=0, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a)) * (k) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k) + (vChange*a1+a)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf,r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    valConds <- unique (data[[valueCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(valConds)-1))#
#
    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Value Change Model Fit: all thresholds::Values::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Value Change Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Overlap Dependent Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Overlap Dependent Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}#
#
summarizeBootOutputCV2 <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  rw.df$correct01 <- ifelse(rw.df$correct == TRUE, 1, 0)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
source("moralsRespBias.r")
source("moralsRespBias.r")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}#
ch.fitAndPlotValueChangeEffect.rt <- function (data, overlapRoundCol,rtCol, valueCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 10, r1=.5, t1=1, t2 = 1, r2=0), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    library(minpack.lm)#
    library(chutils)#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$vChange <- data[[valueCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(valueCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a+thresh*t1)) * (k+thresh*t2) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k+thresh*t2) + (vChange*a1+a+thresh*t1)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf, t1=Inf, t2=Inf, r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, t1=0,t2=0, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a)) * (k) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k) + (vChange*a1+a)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf,r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    valConds <- unique (data[[valueCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(valConds)-1))#
#
    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Value Change Model Fit: all thresholds::Values::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Value Change Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=0,k1=0,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=-Inf,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=0,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Overlap Dependent Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Overlap Dependent Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}#
#
summarizeBootOutputCV2 <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  rw.df$correct01 <- ifelse(rw.df$correct == TRUE, 1, 0)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
source("moralsRespBias.r")
library(chutils)#
#
ch.fitAndPlotCondition.pHit <- function (x,y, cond, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
  ### response bias should be coded so -1 = startpoint farther from the threshold for higher valued item#
  ### and 1 = condition closer to the threshold for higher valued item#
  ### or#
  ### Value Change should be coded so -1 = condition where value change gets items closer together#
  ### and 1 = condition where value change gets items farther apart.#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}#
ch.fitAndPlotValueChangeEffect.rt <- function (data, overlapRoundCol,rtCol, valueCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 10, r1=.5, t1=1, t2 = 1, r2=0), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    library(minpack.lm)#
    library(chutils)#
#
    ### Value Change should be coded so -1 = condition where value change gets items closer together#
    ### and 1 = condition where value change gets items farther apart.#
#
    par(las = 1)#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$vChange <- data[[valueCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(valueCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a+thresh*t1)) * (k+thresh*t2) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k+thresh*t2) + (vChange*a1+a+thresh*t1)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf, t1=Inf, t2=Inf, r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, t1=0,t2=0, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (vChange*a1+a)) * (k) * (exp( ((corr*r1)+(vChange *r2)+r) * Or))) /((k) + (vChange*a1+a)*(exp(((corr*r1)+(vChange *r2)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,r1=Inf,r2=Inf), lower = c(a=-Inf,k=0,r=0,a1=0,r1=-Inf, r2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename)#
    }#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    valConds <- unique (data[[valueCondCol]])#
#
    colSeq <- seq(.1,.4, .3/(length(valConds)-1))#
#
    col.rgb <- NULL#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Value Change Model Fit: all thresholds::Values::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Value Change Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(valConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[valueCondCol]] == valConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[valueCondCol]] == valConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = -50, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
    ### response bias should be coded so -1 = startpoint farther from the threshold for higher valued item#
    ### and 1 = condition closer to the threshold for higher valued item#
#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=0,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=0,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
ch.fitAndPlotOverlapDependentRespBiasEffect.rt <- function (data, overlapRoundCol,rtCol, RespBiasCondCol, correctCol, correctVals = c(TRUE, FALSE), thresholdCondCol,thresholdCondVal = c("fasterThreshold", "slowerThreshold"), startVals = c(a=500, k=1000, r=2, a1 = 100, k1= -100, r1=.5, t1=1, t2 = 1), plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="RT", ...) {#
#
  ### response bias should be coded so -1 = startpoint farther from the threshold for higher valued item#
  ### and 1 = condition closer to the threshold for higher valued item#
    data$Or <- data[[overlapRoundCol]]#
    data$dv <- data[[rtCol]]#
    data$respBias <- data[[RespBiasCondCol]]#
    data$thresh <- ifelse(data[[thresholdCondCol]] == thresholdCondVal[1], 0, 1)#
    data$corr <- ifelse(data[[correctCol]] == correctVals[1], -1, 1)#
#
    grps <- c(RespBiasCondCol, correctCol)#
    df.grpIndex <- ch.getGrpIndex (data, grps)#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(length(thresholdCondVal) > 1) {#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a+thresh*t1)) * (corr*respBias*k1+k+thresh*t2) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k+thresh*t2)+(corr*respBias*a1+a+thresh*t1)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf, t1=Inf, t2=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf, t1=0,t2=0), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      startVals <- startVals[names(startVals)!="t1" & names(startVals)!= "t2"]#
      tryCatch ({#
        nlsFit <- nlsLM(dv ~ (( (corr*respBias*a1+a)) * (corr*respBias*k1+k) * (exp( ((corr*r1)+r) * Or))) /((corr*respBias*k1+k)+(corr*respBias*a1+a)*(exp(((corr*r1)+r)*Or) - 1)), start=startVals, upper = c(a=Inf,k=Inf,r=Inf,a1=Inf,k1=Inf,r1=Inf), lower = c(a=-Inf,k=-Inf,r=0,a1=-Inf,k1=0,r1=-Inf), data=data, control=nls.lm.control(maxiter = 1024) )#
        }, error = function(e) {#
            print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      data$fit <- fitted(nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(data$dv))#
      nlsFit.BIC <- BIC(nlsFit)#
    }#
#
    if (!is.null(filename)) {#
      pdf(filename, width=10, height=8 )#
    }#
    par(mfrow=c(1,1), bg="white",  bty="n", font=2, family='serif', mar=c(5,6,4,10), las=1, cex=1)#
    threshs <- unique(data[[thresholdCondCol]])#
    corrects <- unique(data[[correctCol]])#
    respBiasConds <- unique (data[[RespBiasCondCol]])#
#
    newPlot <- TRUE#
    yLimV <- ch.getPlotAxisMinMax(data$dv)#
    for(i in threshs) {#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = "Overlap Dependent Response Bias Model Fit: all thresholds::Conditions::Corrects", ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
    }#
    ch.addLegend(df.legendVals, grps, ...)#
#
    for(i in threshs) {#
      newPlot <- TRUE#
      yLimV <- ch.getPlotAxisMinMax(data[data[[thresholdCondCol]] == i, "dv"])#
      title <- paste("Overlap Dependent Response Bias Model Fit: threshold =", i, sep=" ")#
      for (j in corrects) {#
        pchVal <- ifelse(j==correctVals[1], 16, 17)#
        for (k in 1:length(respBiasConds)) {#
          df.lgnd <- df.legendVals[df.legendVals[[correctCol]] == j & df.legendVals[[RespBiasCondCol]] == respBiasConds[k],]#
          if (newPlot) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], plot(dv ~ Or, type='p', col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal, ylim=yLimV, main = title, ...))#
            newPlot <- FALSE#
          } else {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], points(dv ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), pch=pchVal))#
          }#
          if(!is.null(nlsFit)) {#
            with(data[data[[thresholdCondCol]] == i & data[[correctCol]] == j & data[[RespBiasCondCol]] == respBiasConds[k],], lines(fit ~ Or, col=hsv(df.lgnd$h,df.lgnd$s,df.lgnd$v), lty=df.lgnd$lty))#
          }#
#
        }#
      }#
      ch.addLegend(df.legendVals, grps, ...)#
    }#
    dev.off()#
#
    return (list(nlsObject = nlsFit, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
}#
summarizeBootOutputCV <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, LVI, distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, LVI,  distShape, startpoint, threshold, decayBeta, noiseSD, responseThreshold) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}#
#
summarizeBootOutputCV2 <- function(rw.df) {#
  trialMax <- max(rw.df$trial)#
  loops <- max(rw.df$loop)#
  rw.df$correct01 <- ifelse(rw.df$correct == TRUE, 1, 0)#
  tmpTable <- rw.df %>% group_by(loop, rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
        samplesMean1 = mean(samples, na.rm=T),#
        samplesMedian1 = median(samples, na.rm=T),#
        rankMean1 = mean(rank, na.rm=T),#
        rankQ251 = quantile(rank,.25),#
        rankQ501 = quantile(rank,.5),#
        rankQ751 = quantile(rank,.75),#
        scaledRankMean1 = mean(scaledRank, na.rm=T),#
        scaledRankQ251 = quantile(scaledRank,.25),#
        scaledRankQ501 = quantile(scaledRank,.5),#
        scaledRankQ751 = quantile(scaledRank,.75),#
        N1 = length(rank),#
        p1 = length(rank)/trialMax)#
  outTable <- tmpTable %>% group_by(rwType, cohensD, Or, HVI, distShape, startpoint, threshold, thresholdAngle, decayBeta, noiseSD, correct) %>% summarize (#
      samplesMean = mean(samplesMean1, na.rm=T), samplesMeanSE = sd(samplesMean1, na.rm=T)/sqrt(loops),#
      samplesMedian = mean(samplesMedian1, na.rm=T), samplesMedianSE = sd(samplesMedian1, na.rm=T)/sqrt(loops),#
      rankMean = mean(rankMean1, na.rm=T), rankMeanSE = sd(rankMean1, na.rm=T)/sqrt(loops),#
      rankQ25 = mean(rankQ251, na.rm=T), rankQ25SE = sd(rankQ251, na.rm=T)/sqrt(loops),#
      rankQ50 = mean(rankQ501, na.rm=T), rankQ50SE = sd(rankQ501, na.rm=T)/sqrt(loops),#
      rankQ75 = mean(rankQ751, na.rm=T), rankQ75SE = sd(rankQ751, na.rm=T)/sqrt(loops),#
      scaledRankMean = mean(scaledRankMean1, na.rm=T), scaledRankMeanSE = sd(scaledRankMean1, na.rm=T)/sqrt(loops),#
      scaledRankQ25 = mean(scaledRankQ251, na.rm=T), scaledRankQ25SE = sd(scaledRankQ251, na.rm=T)/sqrt(loops),#
      scaledRankQ50 = mean(scaledRankQ501, na.rm=T), scaledRankQ50SE = sd(scaledRankQ501, na.rm=T)/sqrt(loops),#
      scaledRankQ75 = mean(scaledRankQ751, na.rm=T), scaledRankQ75SE = sd(scaledRankQ751, na.rm=T)/sqrt(loops),#
      N = mean(N1, na.rm=T), Nse = sd(N1, na.rm=T)/sqrt(loops),#
      p = mean(p1, na.rm=T), pSE = sd(p1, na.rm=T)/sqrt(loops))#
#
 return(data.frame(outTable))#
}
source("moralsRespBias.r")
source("moralsRespBias.r")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, runNoCondEffectModel = FALSE, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
  ### response bias should be coded so -1 = startpoint farther from the threshold for higher valued item#
  ### and 1 = condition closer to the threshold for higher valued item#
  ### or#
  ### Value Change should be coded so -1 = condition where value change gets items closer together#
  ### and 1 = condition where value change gets items farther apart.#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    tryCatch ({#
      if(runNoCondEffectModel == FALSE) {#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
      } else {#
        nlsFit <- nls( y~((1-a)*(1-x^b)+a), start=c(b=1, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
      }#
    })#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
ch.fitAndPlotCondition.pHit <- function (x,y, cond, runNoCondEffectModel = FALSE, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
  ### response bias should be coded so -1 = startpoint farther from the threshold for higher valued item#
  ### and 1 = condition closer to the threshold for higher valued item#
  ### or#
  ### Value Change should be coded so -1 = condition where value change gets items closer together#
  ### and 1 = condition where value change gets items farther apart.#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(runNoCondEffectModel == FALSE) {#
      tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      tryCatch ({#
        nlsFit <- nls( y~((1-a)*(1-x^b)+a), start=c(b=1, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    ch.addLegend(df.legendVals, "cond", ...)#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
source("moralsRespBias.r")
ch.fitAndPlotCondition.pHit <- function (x,y, cond, runNoCondEffectModel = FALSE, plotTitle = NA, filename=NULL, cex1 = 1, printR2 = T,yLabel="p(hit)", ...) {#
#
  ### response bias should be coded so -1 = startpoint farther from the threshold for higher valued item#
  ### and 1 = condition closer to the threshold for higher valued item#
  ### or#
  ### Value Change should be coded so -1 = condition where value change gets items closer together#
  ### and 1 = condition where value change gets items farther apart.#
#
    par(las = 1)#
    df.tmp <- data.frame(x = x, y = y, cond = cond)#
#
    df.grpIndex <- ch.getGrpIndex (df.tmp, "cond")#
    df.legendVals <- ch.getPlotLegendVals(df.grpIndex)#
#
    for(i in 1: length(df.legendVals$cond)) {#
      if (i==1) {#
        with( df.tmp[df.tmp$cond == df.legendVals$cond[i], ], plot(x, y, main=plotTitle, xlab= expression(paste("", Psi,"(value) Distributional overlap", sep="")), ylab=NA, pch=16, ylim = c(0,1), xlim = c(0,1), col = hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i]) ,...))#
        mtext(side=2,yLabel, line=3, cex = cex1)#
        abline(a=0.5,b=0,col="grey", lwd=2)#
      } else {#
        with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], points(x,y, pch = 16, col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
      }#
    }#
#
    nlsFit = NULL#
    nlsFit.r2 = NULL#
    nlsFit.BIC = NULL#
    if(runNoCondEffectModel == FALSE) {#
      tryCatch ({#
        nlsFit <- nls( y~((1-(a+(cond*c)))*(1-x^b)+(a+(cond*c))), start=c(b=1, c=.5, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
      })#
    } else {#
      tryCatch ({#
        nlsFit <- nls( y~((1-a)*(1-x^b)+a), start=c(b=1, a=.5), control = nls.control(minFactor=1/10000000, maxiter=10000, warnOnly = FALSE), algorithm = "port", upper = list(b=30))#
        }, error = function(e) {#
        		print(paste("nls function did not fit", plotTitle, e))#
      })#
    }#
#
    if (!is.null(nlsFit)) {#
      df.tmp$fit <- fitted (nlsFit)#
      nlsFit.r2 <- 1 - (var(resid(nlsFit))/var(df.tmp$y))#
      nlsFit.BIC <- BIC(nlsFit)#
      for(i in 1: length(df.legendVals$cond)) {#
        if(runNoCondEffectModel == FALSE) {#
          with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(df.legendVals$h[i],df.legendVals$s[i], df.legendVals$v[i])))#
        } else {#
          with(df.tmp[df.tmp$cond == df.legendVals$cond[i], ], lines(x,fit, lty = df.legendVals$lty[i], col=hsv(0,0,0)))    #
        }#
      }#
      if (printR2) {#
        r2 <- round(nlsFit.r2, d=2)#
        mtext(side=2, bquote(r^2==.(r2)), line=0, at = -.2, cex = .8*cex1)#
      }#
      nls.beta <- coef(nlsFit)['b']#
      nls.a <- coef(nlsFit)['a']#
      nls.c <- coef(nlsFit)['c']#
    } else {#
				nlsFit.r2 <- NA#
				nls.beta <- NA#
        nls.a <- NA#
        nls.c <- NA#
        nlsFit.BIC <- NA#
		}#
#
    if(runNoCondEffectModel == FALSE) {#
      ch.addLegend(df.legendVals, "cond", ...)#
    }#
#
    if (!is.null(filename)) {#
      dev.copy(pdf, filename, width=10, height=8)#
      dev.off();#
    }#
#
    return (list(nlsObject = nlsFit, beta = nls.beta, a = nls.a, c = nls.c, r2 = nlsFit.r2, BIC = nlsFit.BIC))#
#
}
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
source("moralsRespBias.r")
